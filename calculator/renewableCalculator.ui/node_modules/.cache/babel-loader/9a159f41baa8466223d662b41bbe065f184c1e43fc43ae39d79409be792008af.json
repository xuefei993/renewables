{"ast":null,"code":"// Packaging/modules magic dance.\n(function (factory) {\n  var L;\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['leaflet'], factory);\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    L = require('leaflet');\n    module.exports = factory(L);\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') throw 'Leaflet must be loaded first';\n    factory(window.L);\n  }\n})(function (L) {\n  \"use strict\";\n\n  L.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  };\n\n  /**\n   * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n   * @name L.GeometryUtil\n   */\n\n  L.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n         @tutorial distance-length\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n      return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n      var p = map.latLngToLayerPoint(latlng),\n        p1 = map.latLngToLayerPoint(latlngA),\n        p2 = map.latLngToLayerPoint(latlngB);\n      return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n      var isMetric = unit !== 'imperial',\n        distanceStr;\n      if (isMetric) {\n        // show metres when distance is < 1km, then show km\n        if (distance > 1000) {\n          distanceStr = (distance / 1000).toFixed(2) + ' km';\n        } else {\n          distanceStr = distance.toFixed(1) + ' m';\n        }\n      } else {\n        distance *= 1.09361;\n        if (distance > 1760) {\n          distanceStr = (distance / 1760).toFixed(2) + ' miles';\n        } else {\n          distanceStr = distance.toFixed(1) + ' yd';\n        }\n      }\n      return distanceStr;\n    },\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function (latlng, latlngA, latlngB, tolerance) {\n      tolerance = tolerance === undefined ? 0.2 : tolerance;\n      var hypotenuse = latlngA.distanceTo(latlngB),\n        delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n      return delta / hypotenuse < tolerance;\n    },\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n      var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n      return accumulated.length > 0 ? accumulated[accumulated.length - 1] : 0;\n    },\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n      if (typeof coords.getLatLngs == 'function') {\n        coords = coords.getLatLngs();\n      }\n      if (coords.length === 0) return [];\n      var total = 0,\n        lengths = [0];\n      for (var i = 0, n = coords.length - 1; i < n; i++) {\n        total += coords[i].distanceTo(coords[i + 1]);\n        lengths.push(total);\n      }\n      return lengths;\n    },\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var p = map.project(latlng, maxzoom),\n        p1 = map.project(latlngA, maxzoom),\n        p2 = map.project(latlngB, maxzoom),\n        closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n      return map.unproject(closest, maxzoom);\n    },\n    /**\n    Returns the closest point of a {L.LatLng} on a {L.Circle}\n     @tutorial closest\n     @param {L.LatLng} latlng - The position to search\n    @param {L.Circle} circle - A Circle defined by a center and a radius\n    @returns {L.LatLng} Closest geographical point on the circle circumference\n    */\n    closestOnCircle: function (circle, latLng) {\n      const center = circle.getLatLng();\n      const circleRadius = circle.getRadius();\n      const radius = typeof circleRadius === 'number' ? circleRadius : circleRadius.radius;\n      const x = latLng.lng;\n      const y = latLng.lat;\n      const cx = center.lng;\n      const cy = center.lat;\n      // dx and dy is the vector from the circle's center to latLng\n      const dx = x - cx;\n      const dy = y - cy;\n\n      // distance between the point and the circle's center\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      // Calculate the closest point on the circle by adding the normalized vector to the center\n      const tx = cx + dx / distance * radius;\n      const ty = cy + dy / distance * radius;\n      return new L.LatLng(ty, tx);\n    },\n    /**\n        Returns the closest latlng on layer.\n         Accept nested arrays\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n      var latlngs,\n        mindist = Infinity,\n        result = null,\n        i,\n        n,\n        distance,\n        subResult;\n      if (layer instanceof Array) {\n        // if layer is Array<Array<T>>\n        if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n          // if we have nested arrays, we calc the closest for each array\n          // recursive\n          for (i = 0; i < layer.length; i++) {\n            subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n            if (subResult && subResult.distance < mindist) {\n              mindist = subResult.distance;\n              result = subResult;\n            }\n          }\n          return result;\n        } else if (layer[0] instanceof L.LatLng || typeof layer[0][0] === 'number' || typeof layer[0].lat === 'number') {\n          // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n          layer = L.polyline(layer);\n        } else {\n          return result;\n        }\n      }\n\n      // if we don't have here a Polyline, that means layer is incorrect\n      // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n      if (!(layer instanceof L.Polyline)) return result;\n\n      // deep copy of latlngs\n      latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n      // add the last segment for L.Polygon\n      if (layer instanceof L.Polygon) {\n        // add the last segment for each child that is a nested array\n        var addLastSegment = function (latlngs) {\n          if (L.Polyline._flat(latlngs)) {\n            latlngs.push(latlngs[0]);\n          } else {\n            for (var i = 0; i < latlngs.length; i++) {\n              addLastSegment(latlngs[i]);\n            }\n          }\n        };\n        addLastSegment(latlngs);\n      }\n\n      // we have a multi polygon / multi polyline / polygon with holes\n      // use recursive to explore and return the good result\n      if (!L.Polyline._flat(latlngs)) {\n        for (i = 0; i < latlngs.length; i++) {\n          // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n          subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n          if (subResult.distance < mindist) {\n            mindist = subResult.distance;\n            result = subResult;\n          }\n        }\n        return result;\n      } else {\n        // Lookup vertices\n        if (vertices) {\n          for (i = 0, n = latlngs.length; i < n; i++) {\n            var ll = latlngs[i];\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n            if (distance < mindist) {\n              mindist = distance;\n              result = ll;\n              result.distance = distance;\n            }\n          }\n          return result;\n        }\n\n        // Keep the closest point of all segments\n        for (i = 0, n = latlngs.length; i < n - 1; i++) {\n          var latlngA = latlngs[i],\n            latlngB = latlngs[i + 1];\n          distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n          if (distance <= mindist) {\n            mindist = distance;\n            result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n            result.distance = distance;\n          }\n        }\n        return result;\n      }\n    },\n    /**\n        Returns the closest layer to latlng among a list of layers.\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n      var mindist = Infinity,\n        result = null,\n        ll = null,\n        distance = Infinity;\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n        if (layer instanceof L.LayerGroup) {\n          // recursive\n          var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n          if (subResult.distance < mindist) {\n            mindist = subResult.distance;\n            result = subResult;\n          }\n        } else {\n          if (layer instanceof L.Circle) {\n            ll = this.closestOnCircle(layer, latlng);\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n          } else\n            // Single dimension, snap on points, else snap on closest\n            if (typeof layer.getLatLng == 'function') {\n              ll = layer.getLatLng();\n              distance = L.GeometryUtil.distance(map, latlng, ll);\n            } else {\n              ll = L.GeometryUtil.closest(map, layer, latlng);\n              if (ll) distance = ll.distance; // Can return null if layer has no points.\n            }\n          if (distance < mindist) {\n            mindist = distance;\n            result = {\n              layer: layer,\n              latlng: ll,\n              distance: distance\n            };\n          }\n        }\n      }\n      return result;\n    },\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n         @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n      n = typeof n === 'number' ? n : layers.length;\n      if (n < 1 || layers.length < 1) {\n        return null;\n      }\n      var results = [];\n      var distance, ll;\n      for (var i = 0, m = layers.length; i < m; i++) {\n        var layer = layers[i];\n        if (layer instanceof L.LayerGroup) {\n          // recursive\n          var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n          results.push(subResult);\n        } else {\n          if (layer instanceof L.Circle) {\n            ll = this.closestOnCircle(layer, latlng);\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n          } else\n            // Single dimension, snap on points, else snap on closest\n            if (typeof layer.getLatLng == 'function') {\n              ll = layer.getLatLng();\n              distance = L.GeometryUtil.distance(map, latlng, ll);\n            } else {\n              ll = L.GeometryUtil.closest(map, layer, latlng);\n              if (ll) distance = ll.distance; // Can return null if layer has no points.\n            }\n          results.push({\n            layer: layer,\n            latlng: ll,\n            distance: distance\n          });\n        }\n      }\n      results.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n      if (results.length > n) {\n        return results.slice(0, n);\n      } else {\n        return results;\n      }\n    },\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function (map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n      var results = [];\n      var ll = null;\n      var distance = 0;\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n        if (typeof layer.getLatLng == 'function') {\n          ll = layer.getLatLng();\n          distance = L.GeometryUtil.distance(map, latlng, ll);\n        } else {\n          ll = L.GeometryUtil.closest(map, layer, latlng);\n          if (ll) distance = ll.distance; // Can return null if layer has no points.\n        }\n        if (ll && distance < radius) {\n          results.push({\n            layer: layer,\n            latlng: ll,\n            distance: distance\n          });\n        }\n      }\n      var sortedResults = results.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n      return sortedResults;\n    },\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n      tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n      withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n      var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n      if (!result || result.distance > tolerance) return null;\n\n      // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n      if (withVertices && typeof result.layer.getLatLngs == 'function') {\n        var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n        if (closest.distance < tolerance) {\n          result.latlng = closest;\n          result.distance = L.GeometryUtil.distance(map, closest, latlng);\n        }\n      }\n      return result;\n    },\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n      return L.point(pA.x * (1 - ratio) + ratio * pB.x, pA.y * (1 - ratio) + ratio * pB.y);\n    },\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n      latLngs = latLngs instanceof L.Polyline ? latLngs.getLatLngs() : latLngs;\n      var n = latLngs.length;\n      if (n < 2) {\n        return null;\n      }\n\n      // ensure the ratio is between 0 and 1;\n      ratio = Math.max(Math.min(ratio, 1), 0);\n      if (ratio === 0) {\n        return {\n          latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n          predecessor: -1\n        };\n      }\n      if (ratio == 1) {\n        return {\n          latLng: latLngs[latLngs.length - 1] instanceof L.LatLng ? latLngs[latLngs.length - 1] : L.latLng(latLngs[latLngs.length - 1]),\n          predecessor: latLngs.length - 2\n        };\n      }\n\n      // project the LatLngs as Points,\n      // and compute total planar length of the line at max precision\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var pts = [];\n      var lineLength = 0;\n      for (var i = 0; i < n; i++) {\n        pts[i] = map.project(latLngs[i], maxzoom);\n        if (i > 0) lineLength += pts[i - 1].distanceTo(pts[i]);\n      }\n      var ratioDist = lineLength * ratio;\n\n      // follow the line segments [ab], adding lengths,\n      // until we find the segment where the points should lie on\n      var cumulativeDistanceToA = 0,\n        cumulativeDistanceToB = 0;\n      for (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n        var pointA = pts[i],\n          pointB = pts[i + 1];\n        cumulativeDistanceToA = cumulativeDistanceToB;\n        cumulativeDistanceToB += pointA.distanceTo(pointB);\n      }\n      if (pointA == undefined && pointB == undefined) {\n        // Happens when line has no length\n        var pointA = pts[0],\n          pointB = pts[1],\n          i = 1;\n      }\n\n      // compute the ratio relative to the segment [ab]\n      var segmentRatio = cumulativeDistanceToB - cumulativeDistanceToA !== 0 ? (ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA) : 0;\n      var interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n      return {\n        latLng: map.unproject(interpolatedPoint, maxzoom),\n        predecessor: i - 1\n      };\n    },\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n      var latlngs = polyline.getLatLngs();\n      if (latlng.equals(latlngs[0])) return 0.0;\n      if (latlng.equals(latlngs[latlngs.length - 1])) return 1.0;\n      var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n        lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n        total_length = lengths[lengths.length - 1],\n        portion = 0,\n        found = false;\n      for (var i = 0, n = latlngs.length - 1; i < n; i++) {\n        var l1 = latlngs[i],\n          l2 = latlngs[i + 1];\n        portion = lengths[i];\n        if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n          portion += l1.distanceTo(point);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n      }\n      return portion / total_length;\n    },\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n      return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n      if (start > end) {\n        return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0 - start, 1.0 - end);\n      }\n\n      // Bound start and end to [0-1]\n      start = Math.max(Math.min(start, 1), 0);\n      end = Math.max(Math.min(end, 1), 0);\n      var latlngs = polyline.getLatLngs(),\n        startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n        endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n      // Return single point if start == end\n      if (start == end) {\n        var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        return [point.latLng];\n      }\n      // Array.slice() works indexes at 0\n      if (startpoint.predecessor == -1) startpoint.predecessor = 0;\n      if (endpoint.predecessor == -1) endpoint.predecessor = 0;\n      var result = latlngs.slice(startpoint.predecessor + 1, endpoint.predecessor + 1);\n      result.unshift(startpoint.latLng);\n      result.push(endpoint.latLng);\n      return result;\n    },\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n        llb = other.getLatLngs();\n      return lla[lla.length - 1].equals(llb[0]);\n    },\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n        llb = other.getLatLngs();\n      return lla[0].equals(llb[llb.length - 1]);\n    },\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n        llb = other.getLatLngs(),\n        start = lla[0];\n      return start.equals(llb[0]) || start.equals(llb[llb.length - 1]);\n    },\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function (a, b) {\n      return Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;\n    },\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function (a, b) {\n      var s = (b.y - a.y) / (b.x - a.x),\n        o = a.y - s * a.x;\n      return {\n        'a': s,\n        'b': o\n      };\n    },\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function (map, latlngPoint, angleDeg, latlngCenter) {\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var angleRad = angleDeg * Math.PI / 180,\n        pPoint = map.project(latlngPoint, maxzoom),\n        pCenter = map.project(latlngCenter, maxzoom),\n        x2 = Math.cos(angleRad) * (pPoint.x - pCenter.x) - Math.sin(angleRad) * (pPoint.y - pCenter.y) + pCenter.x,\n        y2 = Math.sin(angleRad) * (pPoint.x - pCenter.x) + Math.cos(angleRad) * (pPoint.y - pCenter.y) + pCenter.y;\n      return map.unproject(new L.Point(x2, y2), maxzoom);\n    },\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        lon1 = latlng1.lng * rad,\n        lon2 = latlng2.lng * rad,\n        y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n        x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n      var bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;\n      return bearing >= 180 ? bearing - 360 : bearing;\n    },\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function (latlng, heading, distance) {\n      heading = (heading + 360) % 360;\n      var rad = Math.PI / 180,\n        radInv = 180 / Math.PI,\n        R = L.CRS.Earth.R,\n        // approximation of Earth's radius\n        lon1 = latlng.lng * rad,\n        lat1 = latlng.lat * rad,\n        rheading = heading * rad,\n        sinLat1 = Math.sin(lat1),\n        cosLat1 = Math.cos(lat1),\n        cosDistR = Math.cos(distance / R),\n        sinDistR = Math.sin(distance / R),\n        lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 * sinDistR * Math.cos(rheading)),\n        lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR * cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n      lon2 = lon2 * radInv;\n      lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n      return L.latLng([lat2 * radInv, lon2]);\n    },\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function (map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n        pointB = map.latLngToContainerPoint(latlngB),\n        angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function (map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n        latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    }\n  });\n  return L.GeometryUtil;\n});","map":{"version":3,"names":["factory","L","define","amd","module","require","exports","window","Polyline","_flat","LineUtil","isFlat","latlngs","Util","isArray","GeometryUtil","extend","distance","map","latlngA","latlngB","latLngToLayerPoint","distanceTo","distanceSegment","latlng","p","p1","p2","pointToSegmentDistance","readableDistance","unit","isMetric","distanceStr","toFixed","belongsSegment","tolerance","undefined","hypotenuse","delta","length","coords","accumulated","accumulatedLengths","getLatLngs","total","lengths","i","n","push","closestOnSegment","maxzoom","getMaxZoom","Infinity","getZoom","project","closest","closestPointOnSegment","unproject","closestOnCircle","circle","latLng","center","getLatLng","circleRadius","getRadius","radius","x","lng","y","lat","cx","cy","dx","dy","Math","sqrt","tx","ty","LatLng","layer","vertices","mindist","result","subResult","Array","polyline","JSON","parse","stringify","slice","Polygon","addLastSegment","ll","closestLayer","layers","LayerGroup","getLayers","Circle","nClosestLayers","results","m","sort","a","b","layersWithin","sortedResults","closestLayerSnap","withVertices","interpolateOnPointSegment","pA","pB","ratio","point","interpolateOnLine","latLngs","max","min","predecessor","pts","lineLength","ratioDist","cumulativeDistanceToA","cumulativeDistanceToB","pointA","pointB","segmentRatio","interpolatedPoint","locateOnLine","equals","total_length","portion","found","l1","l2","toString","reverse","extract","start","end","startpoint","endpoint","unshift","isBefore","other","lla","llb","isAfter","startsAtExtremity","computeAngle","atan2","PI","computeSlope","s","o","rotatePoint","latlngPoint","angleDeg","latlngCenter","angleRad","pPoint","pCenter","x2","cos","sin","y2","Point","bearing","latlng1","latlng2","rad","lat1","lat2","lon1","lon2","destination","heading","radInv","R","CRS","Earth","rheading","sinLat1","cosLat1","cosDistR","sinDistR","asin","angle","latLngToContainerPoint","destinationOnSegment"],"sources":["/Users/xuefei/Desktop/calculator00/calculator/renewableCalculator.ui/node_modules/leaflet-geometryutil/src/leaflet.geometryutil.js"],"sourcesContent":["// Packaging/modules magic dance.\n(function (factory) {\n    var L;\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['leaflet'], factory);\n    } else if (typeof module !== 'undefined') {\n        // Node/CommonJS\n        L = require('leaflet');\n        module.exports = factory(L);\n    } else {\n        // Browser globals\n        if (typeof window.L === 'undefined')\n            throw 'Leaflet must be loaded first';\n        factory(window.L);\n    }\n}(function (L) {\n\"use strict\";\n\nL.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name L.GeometryUtil\n */\n\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n\n        @tutorial distance-length\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n        var p = map.latLngToLayerPoint(latlng),\n           p1 = map.latLngToLayerPoint(latlngA),\n           p2 = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n        var isMetric = (unit !== 'imperial'),\n            distanceStr;\n        if (isMetric) {\n            // show metres when distance is < 1km, then show km\n            if (distance > 1000) {\n                distanceStr = (distance  / 1000).toFixed(2) + ' km';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' m';\n            }\n        }\n        else {\n            distance *= 1.09361;\n            if (distance > 1760) {\n                distanceStr = (distance / 1760).toFixed(2) + ' miles';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' yd';\n            }\n        }\n        return distanceStr;\n    },\n\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {\n        tolerance = tolerance === undefined ? 0.2 : tolerance;\n        var hypotenuse = latlngA.distanceTo(latlngB),\n            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n        return delta/hypotenuse < tolerance;\n    },\n\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n        var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;\n    },\n\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n        if (typeof coords.getLatLngs == 'function') {\n            coords = coords.getLatLngs();\n        }\n        if (coords.length === 0)\n            return [];\n        var total = 0,\n            lengths = [0];\n        for (var i = 0, n = coords.length - 1; i< n; i++) {\n            total += coords[i].distanceTo(coords[i+1]);\n            lengths.push(total);\n        }\n        return lengths;\n    },\n\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var p = map.project(latlng, maxzoom),\n           p1 = map.project(latlngA, maxzoom),\n           p2 = map.project(latlngB, maxzoom),\n           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n        return map.unproject(closest, maxzoom);\n    },\n\n    /**\n    Returns the closest point of a {L.LatLng} on a {L.Circle}\n\n    @tutorial closest\n\n    @param {L.LatLng} latlng - The position to search\n    @param {L.Circle} circle - A Circle defined by a center and a radius\n    @returns {L.LatLng} Closest geographical point on the circle circumference\n    */\n    closestOnCircle: function (circle, latLng) {\n        const center = circle.getLatLng();\n        const circleRadius = circle.getRadius();\n        const radius = typeof circleRadius === 'number' ? circleRadius : circleRadius.radius;\n        const x = latLng.lng;\n        const y = latLng.lat;\n        const cx = center.lng;\n        const cy = center.lat;\n        // dx and dy is the vector from the circle's center to latLng\n        const dx = x - cx;\n        const dy = y - cy;\n\n        // distance between the point and the circle's center\n        const distance = Math.sqrt(dx * dx + dy * dy)\n\n        // Calculate the closest point on the circle by adding the normalized vector to the center\n        const tx = cx + (dx / distance) * radius;\n        const ty = cy + (dy / distance) * radius;\n\n        return new L.LatLng(ty, tx);\n    },\n    \n\n    /**\n        Returns the closest latlng on layer.\n\n        Accept nested arrays\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n\n        var latlngs,\n            mindist = Infinity,\n            result = null,\n            i, n, distance, subResult;\n\n        if (layer instanceof Array) {\n            // if layer is Array<Array<T>>\n            if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n                // if we have nested arrays, we calc the closest for each array\n                // recursive\n                for (i = 0; i < layer.length; i++) {\n                    subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n                    if (subResult && subResult.distance < mindist) {\n                        mindist = subResult.distance;\n                        result = subResult;\n                    }\n                }\n                return result;\n            } else if (layer[0] instanceof L.LatLng\n                        || typeof layer[0][0] === 'number'\n                        || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n                layer = L.polyline(layer);\n            } else {\n                return result;\n            }\n        }\n\n        // if we don't have here a Polyline, that means layer is incorrect\n        // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n        if (! ( layer instanceof L.Polyline ) )\n            return result;\n\n        // deep copy of latlngs\n        latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n        // add the last segment for L.Polygon\n        if (layer instanceof L.Polygon) {\n            // add the last segment for each child that is a nested array\n            var addLastSegment = function(latlngs) {\n                if (L.Polyline._flat(latlngs)) {\n                    latlngs.push(latlngs[0]);\n                } else {\n                    for (var i = 0; i < latlngs.length; i++) {\n                        addLastSegment(latlngs[i]);\n                    }\n                }\n            };\n            addLastSegment(latlngs);\n        }\n\n        // we have a multi polygon / multi polyline / polygon with holes\n        // use recursive to explore and return the good result\n        if ( ! L.Polyline._flat(latlngs) ) {\n            for (i = 0; i < latlngs.length; i++) {\n                // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n                subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n\n        } else {\n\n            // Lookup vertices\n            if (vertices) {\n                for(i = 0, n = latlngs.length; i < n; i++) {\n                    var ll = latlngs[i];\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                    if (distance < mindist) {\n                        mindist = distance;\n                        result = ll;\n                        result.distance = distance;\n                    }\n                }\n                return result;\n            }\n\n            // Keep the closest point of all segments\n            for (i = 0, n = latlngs.length; i < n-1; i++) {\n                var latlngA = latlngs[i],\n                    latlngB = latlngs[i+1];\n                distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n                if (distance <= mindist) {\n                    mindist = distance;\n                    result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n    },\n\n    /**\n        Returns the closest layer to latlng among a list of layers.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n        var mindist = Infinity,\n            result = null,\n            ll = null,\n            distance = Infinity;\n\n        for (var i = 0, n = layers.length; i < n; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            } else {\n                if (layer instanceof L.Circle){\n                    ll = this.closestOnCircle(layer, latlng);\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                } else\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = {layer: layer, latlng: ll, distance: distance};\n                }\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n\n        @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n        n = typeof n === 'number' ? n : layers.length;\n\n        if (n < 1 || layers.length < 1) {\n            return null;\n        }\n\n        var results = [];\n        var distance, ll;\n\n        for (var i = 0, m = layers.length; i < m; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                results.push(subResult);\n            } else {\n                if (layer instanceof L.Circle){\n                    ll = this.closestOnCircle(layer, latlng);\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                } else\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                results.push({layer: layer, latlng: ll, distance: distance});\n            }\n        }\n\n        results.sort(function(a, b) {\n            return a.distance - b.distance;\n        });\n\n        if (results.length > n) {\n            return results.slice(0, n);\n        } else  {\n            return results;\n        }\n    },\n\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function(map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n\n      var results = [];\n      var ll = null;\n      var distance = 0;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n        }\n        else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance;  // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n            results.push({layer: layer, latlng: ll, distance: distance});\n        }\n      }\n\n      var sortedResults = results.sort(function(a, b) {\n          return a.distance - b.distance;\n      });\n\n      return sortedResults;\n    },\n\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n        withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n\n        var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n        if (!result || result.distance > tolerance)\n            return null;\n\n        // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n        if (withVertices && typeof result.layer.getLatLngs == 'function') {\n            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n            if (closest.distance < tolerance) {\n                result.latlng = closest;\n                result.distance = L.GeometryUtil.distance(map, closest, latlng);\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n        return L.point(\n            (pA.x * (1 - ratio)) + (ratio * pB.x),\n            (pA.y * (1 - ratio)) + (ratio * pB.y)\n        );\n    },\n\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\n        var n = latLngs.length;\n        if (n < 2) {\n            return null;\n        }\n\n        // ensure the ratio is between 0 and 1;\n        ratio = Math.max(Math.min(ratio, 1), 0);\n\n        if (ratio === 0) {\n            return {\n                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n                predecessor: -1\n            };\n        }\n        if (ratio == 1) {\n            return {\n                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),\n                predecessor: latLngs.length - 2\n            };\n        }\n\n        // project the LatLngs as Points,\n        // and compute total planar length of the line at max precision\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var pts = [];\n        var lineLength = 0;\n        for(var i = 0; i < n; i++) {\n            pts[i] = map.project(latLngs[i], maxzoom);\n            if(i > 0)\n              lineLength += pts[i-1].distanceTo(pts[i]);\n        }\n\n        var ratioDist = lineLength * ratio;\n\n\t\t// follow the line segments [ab], adding lengths,\n        // until we find the segment where the points should lie on\n\t\tvar cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\n\t\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n\t\t\tvar pointA = pts[i], pointB = pts[i+1];\n\n\t\t\tcumulativeDistanceToA = cumulativeDistanceToB;\n\t\t\tcumulativeDistanceToB += pointA.distanceTo(pointB);\n\t\t}\n\t\t\n\t\tif (pointA == undefined && pointB == undefined) { // Happens when line has no length\n\t\t\tvar pointA = pts[0], pointB = pts[1], i = 1;\n\t\t}\n\n\t\t// compute the ratio relative to the segment [ab]\n\t\tvar segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\n\t\tvar interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n\t\treturn {\n\t\t\tlatLng: map.unproject(interpolatedPoint, maxzoom),\n\t\t\tpredecessor: i-1\n\t\t};\n    },\n\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n        var latlngs = polyline.getLatLngs();\n        if (latlng.equals(latlngs[0]))\n            return 0.0;\n        if (latlng.equals(latlngs[latlngs.length-1]))\n            return 1.0;\n\n        var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n            lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n            total_length = lengths[lengths.length-1],\n            portion = 0,\n            found = false;\n        for (var i=0, n = latlngs.length-1; i < n; i++) {\n            var l1 = latlngs[i],\n                l2 = latlngs[i+1];\n            portion = lengths[i];\n            if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n                portion += l1.distanceTo(point);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n        }\n        return portion / total_length;\n    },\n\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n        return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n        if (start > end) {\n            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);\n        }\n\n        // Bound start and end to [0-1]\n        start = Math.max(Math.min(start, 1), 0);\n        end = Math.max(Math.min(end, 1), 0);\n\n        var latlngs = polyline.getLatLngs(),\n            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        // Return single point if start == end\n        if (start == end) {\n            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n            return [point.latLng];\n        }\n        // Array.slice() works indexes at 0\n        if (startpoint.predecessor == -1)\n            startpoint.predecessor = 0;\n        if (endpoint.predecessor == -1)\n            endpoint.predecessor = 0;\n        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);\n        result.unshift(startpoint.latLng);\n        result.push(endpoint.latLng);\n        return result;\n    },\n\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[lla.length-1]).equals(llb[0]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[0]).equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs(),\n            start = lla[0];\n        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function(a, b) {\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n    },\n\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function(a, b) {\n        var s = (b.y - a.y) / (b.x - a.x),\n            o = a.y - (s * a.x);\n        return {'a': s, 'b': o};\n    },\n\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var angleRad = angleDeg*Math.PI/180,\n            pPoint = map.project(latlngPoint, maxzoom),\n            pCenter = map.project(latlngCenter, maxzoom),\n            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,\n            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;\n        return map.unproject(new L.Point(x2,y2), maxzoom);\n    },\n\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function(latlng1, latlng2) {\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            lon1 = latlng1.lng * rad,\n            lon2 = latlng2.lng * rad,\n            y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n            x = Math.cos(lat1) * Math.sin(lat2) -\n                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n        return bearing >= 180 ? bearing-360 : bearing;\n    },\n\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function(latlng, heading, distance) {\n        heading = (heading + 360) % 360;\n        var rad = Math.PI / 180,\n            radInv = 180 / Math.PI,\n            R = L.CRS.Earth.R, // approximation of Earth's radius\n            lon1 = latlng.lng * rad,\n            lat1 = latlng.lat * rad,\n            rheading = heading * rad,\n            sinLat1 = Math.sin(lat1),\n            cosLat1 = Math.cos(lat1),\n            cosDistR = Math.cos(distance / R),\n            sinDistR = Math.sin(distance / R),\n            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n                sinDistR * Math.cos(rheading)),\n            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n        lon2 = lon2 * radInv;\n        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n        return L.latLng([lat2 * radInv, lon2]);\n    },\n\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function(map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n          pointB = map.latLngToContainerPoint(latlngB),\n          angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function(map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n          latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    },\n});\n\nreturn L.GeometryUtil;\n\n}));\n"],"mappings":"AAAA;AACC,WAAUA,OAAO,EAAE;EAChB,IAAIC,CAAC;EACL,IAAI,OAAOC,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,EAAE;IAC5C;IACAD,MAAM,CAAC,CAAC,SAAS,CAAC,EAAEF,OAAO,CAAC;EAChC,CAAC,MAAM,IAAI,OAAOI,MAAM,KAAK,WAAW,EAAE;IACtC;IACAH,CAAC,GAAGI,OAAO,CAAC,SAAS,CAAC;IACtBD,MAAM,CAACE,OAAO,GAAGN,OAAO,CAACC,CAAC,CAAC;EAC/B,CAAC,MAAM;IACH;IACA,IAAI,OAAOM,MAAM,CAACN,CAAC,KAAK,WAAW,EAC/B,MAAM,8BAA8B;IACxCD,OAAO,CAACO,MAAM,CAACN,CAAC,CAAC;EACrB;AACJ,CAAC,EAAC,UAAUA,CAAC,EAAE;EACf,YAAY;;EAEZA,CAAC,CAACO,QAAQ,CAACC,KAAK,GAAGR,CAAC,CAACS,QAAQ,CAACC,MAAM,IAAIV,CAAC,CAACO,QAAQ,CAACC,KAAK,IAAI,UAAUG,OAAO,EAAE;IAC3E;IACA,OAAO,CAACX,CAAC,CAACY,IAAI,CAACC,OAAO,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC,IAAK,OAAOA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,WAAY;EACrH,CAAC;;EAED;AACA;AACA;AACA;;EAEAX,CAAC,CAACc,YAAY,GAAGd,CAAC,CAACe,MAAM,CAACf,CAAC,CAACc,YAAY,IAAI,CAAC,CAAC,EAAE;IAE5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IAGIE,QAAQ,EAAE,SAAAA,CAAUC,GAAG,EAAEC,OAAO,EAAEC,OAAO,EAAE;MACvC,OAAOF,GAAG,CAACG,kBAAkB,CAACF,OAAO,CAAC,CAACG,UAAU,CAACJ,GAAG,CAACG,kBAAkB,CAACD,OAAO,CAAC,CAAC;IACtF,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIG,eAAe,EAAE,SAAAA,CAAUL,GAAG,EAAEM,MAAM,EAAEL,OAAO,EAAEC,OAAO,EAAE;MACtD,IAAIK,CAAC,GAAGP,GAAG,CAACG,kBAAkB,CAACG,MAAM,CAAC;QACnCE,EAAE,GAAGR,GAAG,CAACG,kBAAkB,CAACF,OAAO,CAAC;QACpCQ,EAAE,GAAGT,GAAG,CAACG,kBAAkB,CAACD,OAAO,CAAC;MACvC,OAAOnB,CAAC,CAACS,QAAQ,CAACkB,sBAAsB,CAACH,CAAC,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACvD,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;IACIE,gBAAgB,EAAE,SAAAA,CAAUZ,QAAQ,EAAEa,IAAI,EAAE;MACxC,IAAIC,QAAQ,GAAID,IAAI,KAAK,UAAW;QAChCE,WAAW;MACf,IAAID,QAAQ,EAAE;QACV;QACA,IAAId,QAAQ,GAAG,IAAI,EAAE;UACjBe,WAAW,GAAG,CAACf,QAAQ,GAAI,IAAI,EAAEgB,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK;QACvD,CAAC,MACI;UACDD,WAAW,GAAGf,QAAQ,CAACgB,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI;QAC5C;MACJ,CAAC,MACI;QACDhB,QAAQ,IAAI,OAAO;QACnB,IAAIA,QAAQ,GAAG,IAAI,EAAE;UACjBe,WAAW,GAAG,CAACf,QAAQ,GAAG,IAAI,EAAEgB,OAAO,CAAC,CAAC,CAAC,GAAG,QAAQ;QACzD,CAAC,MACI;UACDD,WAAW,GAAGf,QAAQ,CAACgB,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK;QAC7C;MACJ;MACA,OAAOD,WAAW;IACtB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIE,cAAc,EAAE,SAAAA,CAASV,MAAM,EAAEL,OAAO,EAAEC,OAAO,EAAEe,SAAS,EAAE;MAC1DA,SAAS,GAAGA,SAAS,KAAKC,SAAS,GAAG,GAAG,GAAGD,SAAS;MACrD,IAAIE,UAAU,GAAGlB,OAAO,CAACG,UAAU,CAACF,OAAO,CAAC;QACxCkB,KAAK,GAAGnB,OAAO,CAACG,UAAU,CAACE,MAAM,CAAC,GAAGA,MAAM,CAACF,UAAU,CAACF,OAAO,CAAC,GAAGiB,UAAU;MAChF,OAAOC,KAAK,GAACD,UAAU,GAAGF,SAAS;IACvC,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;IACII,MAAM,EAAE,SAAAA,CAAUC,MAAM,EAAE;MACtB,IAAIC,WAAW,GAAGxC,CAAC,CAACc,YAAY,CAAC2B,kBAAkB,CAACF,MAAM,CAAC;MAC3D,OAAOC,WAAW,CAACF,MAAM,GAAG,CAAC,GAAGE,WAAW,CAACA,WAAW,CAACF,MAAM,GAAC,CAAC,CAAC,GAAG,CAAC;IACzE,CAAC;IAED;AACJ;AACA;AACA;AACA;IACIG,kBAAkB,EAAE,SAAAA,CAAUF,MAAM,EAAE;MAClC,IAAI,OAAOA,MAAM,CAACG,UAAU,IAAI,UAAU,EAAE;QACxCH,MAAM,GAAGA,MAAM,CAACG,UAAU,CAAC,CAAC;MAChC;MACA,IAAIH,MAAM,CAACD,MAAM,KAAK,CAAC,EACnB,OAAO,EAAE;MACb,IAAIK,KAAK,GAAG,CAAC;QACTC,OAAO,GAAG,CAAC,CAAC,CAAC;MACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGP,MAAM,CAACD,MAAM,GAAG,CAAC,EAAEO,CAAC,GAAEC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC9CF,KAAK,IAAIJ,MAAM,CAACM,CAAC,CAAC,CAACxB,UAAU,CAACkB,MAAM,CAACM,CAAC,GAAC,CAAC,CAAC,CAAC;QAC1CD,OAAO,CAACG,IAAI,CAACJ,KAAK,CAAC;MACvB;MACA,OAAOC,OAAO;IAClB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAGII,gBAAgB,EAAE,SAAAA,CAAU/B,GAAG,EAAEM,MAAM,EAAEL,OAAO,EAAEC,OAAO,EAAE;MACvD,IAAI8B,OAAO,GAAGhC,GAAG,CAACiC,UAAU,CAAC,CAAC;MAC9B,IAAID,OAAO,KAAKE,QAAQ,EACpBF,OAAO,GAAGhC,GAAG,CAACmC,OAAO,CAAC,CAAC;MAC3B,IAAI5B,CAAC,GAAGP,GAAG,CAACoC,OAAO,CAAC9B,MAAM,EAAE0B,OAAO,CAAC;QACjCxB,EAAE,GAAGR,GAAG,CAACoC,OAAO,CAACnC,OAAO,EAAE+B,OAAO,CAAC;QAClCvB,EAAE,GAAGT,GAAG,CAACoC,OAAO,CAAClC,OAAO,EAAE8B,OAAO,CAAC;QAClCK,OAAO,GAAGtD,CAAC,CAACS,QAAQ,CAAC8C,qBAAqB,CAAC/B,CAAC,EAAEC,EAAE,EAAEC,EAAE,CAAC;MACxD,OAAOT,GAAG,CAACuC,SAAS,CAACF,OAAO,EAAEL,OAAO,CAAC;IAC1C,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;IAGIQ,eAAe,EAAE,SAAAA,CAAUC,MAAM,EAAEC,MAAM,EAAE;MACvC,MAAMC,MAAM,GAAGF,MAAM,CAACG,SAAS,CAAC,CAAC;MACjC,MAAMC,YAAY,GAAGJ,MAAM,CAACK,SAAS,CAAC,CAAC;MACvC,MAAMC,MAAM,GAAG,OAAOF,YAAY,KAAK,QAAQ,GAAGA,YAAY,GAAGA,YAAY,CAACE,MAAM;MACpF,MAAMC,CAAC,GAAGN,MAAM,CAACO,GAAG;MACpB,MAAMC,CAAC,GAAGR,MAAM,CAACS,GAAG;MACpB,MAAMC,EAAE,GAAGT,MAAM,CAACM,GAAG;MACrB,MAAMI,EAAE,GAAGV,MAAM,CAACQ,GAAG;MACrB;MACA,MAAMG,EAAE,GAAGN,CAAC,GAAGI,EAAE;MACjB,MAAMG,EAAE,GAAGL,CAAC,GAAGG,EAAE;;MAEjB;MACA,MAAMtD,QAAQ,GAAGyD,IAAI,CAACC,IAAI,CAACH,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE,CAAC;;MAE7C;MACA,MAAMG,EAAE,GAAGN,EAAE,GAAIE,EAAE,GAAGvD,QAAQ,GAAIgD,MAAM;MACxC,MAAMY,EAAE,GAAGN,EAAE,GAAIE,EAAE,GAAGxD,QAAQ,GAAIgD,MAAM;MAExC,OAAO,IAAIhE,CAAC,CAAC6E,MAAM,CAACD,EAAE,EAAED,EAAE,CAAC;IAC/B,CAAC;IAGD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAIIrB,OAAO,EAAE,SAAAA,CAAUrC,GAAG,EAAE6D,KAAK,EAAEvD,MAAM,EAAEwD,QAAQ,EAAE;MAE7C,IAAIpE,OAAO;QACPqE,OAAO,GAAG7B,QAAQ;QAClB8B,MAAM,GAAG,IAAI;QACbpC,CAAC;QAAEC,CAAC;QAAE9B,QAAQ;QAAEkE,SAAS;MAE7B,IAAIJ,KAAK,YAAYK,KAAK,EAAE;QACxB;QACA,IAAIL,KAAK,CAAC,CAAC,CAAC,YAAYK,KAAK,IAAI,OAAOL,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;UAC9D;UACA;UACA,KAAKjC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,KAAK,CAACxC,MAAM,EAAEO,CAAC,EAAE,EAAE;YAC/BqC,SAAS,GAAGlF,CAAC,CAACc,YAAY,CAACwC,OAAO,CAACrC,GAAG,EAAE6D,KAAK,CAACjC,CAAC,CAAC,EAAEtB,MAAM,EAAEwD,QAAQ,CAAC;YACnE,IAAIG,SAAS,IAAIA,SAAS,CAAClE,QAAQ,GAAGgE,OAAO,EAAE;cAC3CA,OAAO,GAAGE,SAAS,CAAClE,QAAQ;cAC5BiE,MAAM,GAAGC,SAAS;YACtB;UACJ;UACA,OAAOD,MAAM;QACjB,CAAC,MAAM,IAAIH,KAAK,CAAC,CAAC,CAAC,YAAY9E,CAAC,CAAC6E,MAAM,IACxB,OAAOC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,IAC/B,OAAOA,KAAK,CAAC,CAAC,CAAC,CAACV,GAAG,KAAK,QAAQ,EAAE;UAAE;UAC/CU,KAAK,GAAG9E,CAAC,CAACoF,QAAQ,CAACN,KAAK,CAAC;QAC7B,CAAC,MAAM;UACH,OAAOG,MAAM;QACjB;MACJ;;MAEA;MACA;MACA,IAAI,EAAIH,KAAK,YAAY9E,CAAC,CAACO,QAAQ,CAAE,EACjC,OAAO0E,MAAM;;MAEjB;MACAtE,OAAO,GAAG0E,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACT,KAAK,CAACpC,UAAU,CAAC,CAAC,CAAC8C,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;MAEjE;MACA,IAAIV,KAAK,YAAY9E,CAAC,CAACyF,OAAO,EAAE;QAC5B;QACA,IAAIC,cAAc,GAAG,SAAAA,CAAS/E,OAAO,EAAE;UACnC,IAAIX,CAAC,CAACO,QAAQ,CAACC,KAAK,CAACG,OAAO,CAAC,EAAE;YAC3BA,OAAO,CAACoC,IAAI,CAACpC,OAAO,CAAC,CAAC,CAAC,CAAC;UAC5B,CAAC,MAAM;YACH,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlC,OAAO,CAAC2B,MAAM,EAAEO,CAAC,EAAE,EAAE;cACrC6C,cAAc,CAAC/E,OAAO,CAACkC,CAAC,CAAC,CAAC;YAC9B;UACJ;QACJ,CAAC;QACD6C,cAAc,CAAC/E,OAAO,CAAC;MAC3B;;MAEA;MACA;MACA,IAAK,CAAEX,CAAC,CAACO,QAAQ,CAACC,KAAK,CAACG,OAAO,CAAC,EAAG;QAC/B,KAAKkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlC,OAAO,CAAC2B,MAAM,EAAEO,CAAC,EAAE,EAAE;UACjC;UACAqC,SAAS,GAAGlF,CAAC,CAACc,YAAY,CAACwC,OAAO,CAACrC,GAAG,EAAEN,OAAO,CAACkC,CAAC,CAAC,EAAEtB,MAAM,EAAEwD,QAAQ,CAAC;UACrE,IAAIG,SAAS,CAAClE,QAAQ,GAAGgE,OAAO,EAAE;YAC9BA,OAAO,GAAGE,SAAS,CAAClE,QAAQ;YAC5BiE,MAAM,GAAGC,SAAS;UACtB;QACJ;QACA,OAAOD,MAAM;MAEjB,CAAC,MAAM;QAEH;QACA,IAAIF,QAAQ,EAAE;UACV,KAAIlC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGnC,OAAO,CAAC2B,MAAM,EAAEO,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YACvC,IAAI8C,EAAE,GAAGhF,OAAO,CAACkC,CAAC,CAAC;YACnB7B,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACE,QAAQ,CAACC,GAAG,EAAEM,MAAM,EAAEoE,EAAE,CAAC;YACnD,IAAI3E,QAAQ,GAAGgE,OAAO,EAAE;cACpBA,OAAO,GAAGhE,QAAQ;cAClBiE,MAAM,GAAGU,EAAE;cACXV,MAAM,CAACjE,QAAQ,GAAGA,QAAQ;YAC9B;UACJ;UACA,OAAOiE,MAAM;QACjB;;QAEA;QACA,KAAKpC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGnC,OAAO,CAAC2B,MAAM,EAAEO,CAAC,GAAGC,CAAC,GAAC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC1C,IAAI3B,OAAO,GAAGP,OAAO,CAACkC,CAAC,CAAC;YACpB1B,OAAO,GAAGR,OAAO,CAACkC,CAAC,GAAC,CAAC,CAAC;UAC1B7B,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACQ,eAAe,CAACL,GAAG,EAAEM,MAAM,EAAEL,OAAO,EAAEC,OAAO,CAAC;UACxE,IAAIH,QAAQ,IAAIgE,OAAO,EAAE;YACrBA,OAAO,GAAGhE,QAAQ;YAClBiE,MAAM,GAAGjF,CAAC,CAACc,YAAY,CAACkC,gBAAgB,CAAC/B,GAAG,EAAEM,MAAM,EAAEL,OAAO,EAAEC,OAAO,CAAC;YACvE8D,MAAM,CAACjE,QAAQ,GAAGA,QAAQ;UAC9B;QACJ;QACA,OAAOiE,MAAM;MACjB;IAEJ,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IAGIW,YAAY,EAAE,SAAAA,CAAU3E,GAAG,EAAE4E,MAAM,EAAEtE,MAAM,EAAE;MACzC,IAAIyD,OAAO,GAAG7B,QAAQ;QAClB8B,MAAM,GAAG,IAAI;QACbU,EAAE,GAAG,IAAI;QACT3E,QAAQ,GAAGmC,QAAQ;MAEvB,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG+C,MAAM,CAACvD,MAAM,EAAEO,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC3C,IAAIiC,KAAK,GAAGe,MAAM,CAAChD,CAAC,CAAC;QACrB,IAAIiC,KAAK,YAAY9E,CAAC,CAAC8F,UAAU,EAAE;UAC/B;UACA,IAAIZ,SAAS,GAAGlF,CAAC,CAACc,YAAY,CAAC8E,YAAY,CAAC3E,GAAG,EAAE6D,KAAK,CAACiB,SAAS,CAAC,CAAC,EAAExE,MAAM,CAAC;UAC3E,IAAI2D,SAAS,CAAClE,QAAQ,GAAGgE,OAAO,EAAE;YAC9BA,OAAO,GAAGE,SAAS,CAAClE,QAAQ;YAC5BiE,MAAM,GAAGC,SAAS;UACtB;QACJ,CAAC,MAAM;UACH,IAAIJ,KAAK,YAAY9E,CAAC,CAACgG,MAAM,EAAC;YAC1BL,EAAE,GAAG,IAAI,CAAClC,eAAe,CAACqB,KAAK,EAAEvD,MAAM,CAAC;YACxCP,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACE,QAAQ,CAACC,GAAG,EAAEM,MAAM,EAAEoE,EAAE,CAAC;UACvD,CAAC;YACD;YACA,IAAI,OAAOb,KAAK,CAACjB,SAAS,IAAI,UAAU,EAAE;cACtC8B,EAAE,GAAGb,KAAK,CAACjB,SAAS,CAAC,CAAC;cACtB7C,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACE,QAAQ,CAACC,GAAG,EAAEM,MAAM,EAAEoE,EAAE,CAAC;YACvD,CAAC,MACI;cACDA,EAAE,GAAG3F,CAAC,CAACc,YAAY,CAACwC,OAAO,CAACrC,GAAG,EAAE6D,KAAK,EAAEvD,MAAM,CAAC;cAC/C,IAAIoE,EAAE,EAAE3E,QAAQ,GAAG2E,EAAE,CAAC3E,QAAQ,CAAC,CAAE;YACrC;UACA,IAAIA,QAAQ,GAAGgE,OAAO,EAAE;YACpBA,OAAO,GAAGhE,QAAQ;YAClBiE,MAAM,GAAG;cAACH,KAAK,EAAEA,KAAK;cAAEvD,MAAM,EAAEoE,EAAE;cAAE3E,QAAQ,EAAEA;YAAQ,CAAC;UAC3D;QACJ;MACJ;MACA,OAAOiE,MAAM;IACjB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IAEIgB,cAAc,EAAE,SAAAA,CAAUhF,GAAG,EAAE4E,MAAM,EAAEtE,MAAM,EAAEuB,CAAC,EAAE;MAC9CA,CAAC,GAAG,OAAOA,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAG+C,MAAM,CAACvD,MAAM;MAE7C,IAAIQ,CAAC,GAAG,CAAC,IAAI+C,MAAM,CAACvD,MAAM,GAAG,CAAC,EAAE;QAC5B,OAAO,IAAI;MACf;MAEA,IAAI4D,OAAO,GAAG,EAAE;MAChB,IAAIlF,QAAQ,EAAE2E,EAAE;MAEhB,KAAK,IAAI9C,CAAC,GAAG,CAAC,EAAEsD,CAAC,GAAGN,MAAM,CAACvD,MAAM,EAAEO,CAAC,GAAGsD,CAAC,EAAEtD,CAAC,EAAE,EAAE;QAC3C,IAAIiC,KAAK,GAAGe,MAAM,CAAChD,CAAC,CAAC;QACrB,IAAIiC,KAAK,YAAY9E,CAAC,CAAC8F,UAAU,EAAE;UAC/B;UACA,IAAIZ,SAAS,GAAGlF,CAAC,CAACc,YAAY,CAAC8E,YAAY,CAAC3E,GAAG,EAAE6D,KAAK,CAACiB,SAAS,CAAC,CAAC,EAAExE,MAAM,CAAC;UAC3E2E,OAAO,CAACnD,IAAI,CAACmC,SAAS,CAAC;QAC3B,CAAC,MAAM;UACH,IAAIJ,KAAK,YAAY9E,CAAC,CAACgG,MAAM,EAAC;YAC1BL,EAAE,GAAG,IAAI,CAAClC,eAAe,CAACqB,KAAK,EAAEvD,MAAM,CAAC;YACxCP,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACE,QAAQ,CAACC,GAAG,EAAEM,MAAM,EAAEoE,EAAE,CAAC;UACvD,CAAC;YACD;YACA,IAAI,OAAOb,KAAK,CAACjB,SAAS,IAAI,UAAU,EAAE;cACtC8B,EAAE,GAAGb,KAAK,CAACjB,SAAS,CAAC,CAAC;cACtB7C,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACE,QAAQ,CAACC,GAAG,EAAEM,MAAM,EAAEoE,EAAE,CAAC;YACvD,CAAC,MACI;cACDA,EAAE,GAAG3F,CAAC,CAACc,YAAY,CAACwC,OAAO,CAACrC,GAAG,EAAE6D,KAAK,EAAEvD,MAAM,CAAC;cAC/C,IAAIoE,EAAE,EAAE3E,QAAQ,GAAG2E,EAAE,CAAC3E,QAAQ,CAAC,CAAE;YACrC;UACAkF,OAAO,CAACnD,IAAI,CAAC;YAAC+B,KAAK,EAAEA,KAAK;YAAEvD,MAAM,EAAEoE,EAAE;YAAE3E,QAAQ,EAAEA;UAAQ,CAAC,CAAC;QAChE;MACJ;MAEAkF,OAAO,CAACE,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAE;QACxB,OAAOD,CAAC,CAACrF,QAAQ,GAAGsF,CAAC,CAACtF,QAAQ;MAClC,CAAC,CAAC;MAEF,IAAIkF,OAAO,CAAC5D,MAAM,GAAGQ,CAAC,EAAE;QACpB,OAAOoD,OAAO,CAACV,KAAK,CAAC,CAAC,EAAE1C,CAAC,CAAC;MAC9B,CAAC,MAAO;QACJ,OAAOoD,OAAO;MAClB;IACJ,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIK,YAAY,EAAE,SAAAA,CAAStF,GAAG,EAAE4E,MAAM,EAAEtE,MAAM,EAAEyC,MAAM,EAAE;MAClDA,MAAM,GAAG,OAAOA,MAAM,IAAI,QAAQ,GAAGA,MAAM,GAAGb,QAAQ;MAEtD,IAAI+C,OAAO,GAAG,EAAE;MAChB,IAAIP,EAAE,GAAG,IAAI;MACb,IAAI3E,QAAQ,GAAG,CAAC;MAEhB,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG+C,MAAM,CAACvD,MAAM,EAAEO,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC7C,IAAIiC,KAAK,GAAGe,MAAM,CAAChD,CAAC,CAAC;QAErB,IAAI,OAAOiC,KAAK,CAACjB,SAAS,IAAI,UAAU,EAAE;UACtC8B,EAAE,GAAGb,KAAK,CAACjB,SAAS,CAAC,CAAC;UACtB7C,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACE,QAAQ,CAACC,GAAG,EAAEM,MAAM,EAAEoE,EAAE,CAAC;QACvD,CAAC,MACI;UACDA,EAAE,GAAG3F,CAAC,CAACc,YAAY,CAACwC,OAAO,CAACrC,GAAG,EAAE6D,KAAK,EAAEvD,MAAM,CAAC;UAC/C,IAAIoE,EAAE,EAAE3E,QAAQ,GAAG2E,EAAE,CAAC3E,QAAQ,CAAC,CAAE;QACrC;QAEA,IAAI2E,EAAE,IAAI3E,QAAQ,GAAGgD,MAAM,EAAE;UACzBkC,OAAO,CAACnD,IAAI,CAAC;YAAC+B,KAAK,EAAEA,KAAK;YAAEvD,MAAM,EAAEoE,EAAE;YAAE3E,QAAQ,EAAEA;UAAQ,CAAC,CAAC;QAChE;MACF;MAEA,IAAIwF,aAAa,GAAGN,OAAO,CAACE,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAE;QAC5C,OAAOD,CAAC,CAACrF,QAAQ,GAAGsF,CAAC,CAACtF,QAAQ;MAClC,CAAC,CAAC;MAEF,OAAOwF,aAAa;IACtB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAGIC,gBAAgB,EAAE,SAAAA,CAAUxF,GAAG,EAAE4E,MAAM,EAAEtE,MAAM,EAAEW,SAAS,EAAEwE,YAAY,EAAE;MACtExE,SAAS,GAAG,OAAOA,SAAS,IAAI,QAAQ,GAAGA,SAAS,GAAGiB,QAAQ;MAC/DuD,YAAY,GAAG,OAAOA,YAAY,IAAI,SAAS,GAAGA,YAAY,GAAG,IAAI;MAErE,IAAIzB,MAAM,GAAGjF,CAAC,CAACc,YAAY,CAAC8E,YAAY,CAAC3E,GAAG,EAAE4E,MAAM,EAAEtE,MAAM,CAAC;MAC7D,IAAI,CAAC0D,MAAM,IAAIA,MAAM,CAACjE,QAAQ,GAAGkB,SAAS,EACtC,OAAO,IAAI;;MAEf;MACA,IAAIwE,YAAY,IAAI,OAAOzB,MAAM,CAACH,KAAK,CAACpC,UAAU,IAAI,UAAU,EAAE;QAC9D,IAAIY,OAAO,GAAGtD,CAAC,CAACc,YAAY,CAACwC,OAAO,CAACrC,GAAG,EAAEgE,MAAM,CAACH,KAAK,EAAEG,MAAM,CAAC1D,MAAM,EAAE,IAAI,CAAC;QAC5E,IAAI+B,OAAO,CAACtC,QAAQ,GAAGkB,SAAS,EAAE;UAC9B+C,MAAM,CAAC1D,MAAM,GAAG+B,OAAO;UACvB2B,MAAM,CAACjE,QAAQ,GAAGhB,CAAC,CAACc,YAAY,CAACE,QAAQ,CAACC,GAAG,EAAEqC,OAAO,EAAE/B,MAAM,CAAC;QACnE;MACJ;MACA,OAAO0D,MAAM;IACjB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;IACI0B,yBAAyB,EAAE,SAAAA,CAAUC,EAAE,EAAEC,EAAE,EAAEC,KAAK,EAAE;MAChD,OAAO9G,CAAC,CAAC+G,KAAK,CACTH,EAAE,CAAC3C,CAAC,IAAI,CAAC,GAAG6C,KAAK,CAAC,GAAKA,KAAK,GAAGD,EAAE,CAAC5C,CAAE,EACpC2C,EAAE,CAACzC,CAAC,IAAI,CAAC,GAAG2C,KAAK,CAAC,GAAKA,KAAK,GAAGD,EAAE,CAAC1C,CACvC,CAAC;IACL,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI6C,iBAAiB,EAAE,SAAAA,CAAU/F,GAAG,EAAEgG,OAAO,EAAEH,KAAK,EAAE;MAC9CG,OAAO,GAAIA,OAAO,YAAYjH,CAAC,CAACO,QAAQ,GAAI0G,OAAO,CAACvE,UAAU,CAAC,CAAC,GAAGuE,OAAO;MAC1E,IAAInE,CAAC,GAAGmE,OAAO,CAAC3E,MAAM;MACtB,IAAIQ,CAAC,GAAG,CAAC,EAAE;QACP,OAAO,IAAI;MACf;;MAEA;MACAgE,KAAK,GAAGrC,IAAI,CAACyC,GAAG,CAACzC,IAAI,CAAC0C,GAAG,CAACL,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAEvC,IAAIA,KAAK,KAAK,CAAC,EAAE;QACb,OAAO;UACHnD,MAAM,EAAEsD,OAAO,CAAC,CAAC,CAAC,YAAYjH,CAAC,CAAC6E,MAAM,GAAGoC,OAAO,CAAC,CAAC,CAAC,GAAGjH,CAAC,CAAC2D,MAAM,CAACsD,OAAO,CAAC,CAAC,CAAC,CAAC;UAC1EG,WAAW,EAAE,CAAC;QAClB,CAAC;MACL;MACA,IAAIN,KAAK,IAAI,CAAC,EAAE;QACZ,OAAO;UACHnD,MAAM,EAAEsD,OAAO,CAACA,OAAO,CAAC3E,MAAM,GAAE,CAAC,CAAC,YAAYtC,CAAC,CAAC6E,MAAM,GAAGoC,OAAO,CAACA,OAAO,CAAC3E,MAAM,GAAE,CAAC,CAAC,GAAGtC,CAAC,CAAC2D,MAAM,CAACsD,OAAO,CAACA,OAAO,CAAC3E,MAAM,GAAE,CAAC,CAAC,CAAC;UAC1H8E,WAAW,EAAEH,OAAO,CAAC3E,MAAM,GAAG;QAClC,CAAC;MACL;;MAEA;MACA;MACA,IAAIW,OAAO,GAAGhC,GAAG,CAACiC,UAAU,CAAC,CAAC;MAC9B,IAAID,OAAO,KAAKE,QAAQ,EACpBF,OAAO,GAAGhC,GAAG,CAACmC,OAAO,CAAC,CAAC;MAC3B,IAAIiE,GAAG,GAAG,EAAE;MACZ,IAAIC,UAAU,GAAG,CAAC;MAClB,KAAI,IAAIzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QACvBwE,GAAG,CAACxE,CAAC,CAAC,GAAG5B,GAAG,CAACoC,OAAO,CAAC4D,OAAO,CAACpE,CAAC,CAAC,EAAEI,OAAO,CAAC;QACzC,IAAGJ,CAAC,GAAG,CAAC,EACNyE,UAAU,IAAID,GAAG,CAACxE,CAAC,GAAC,CAAC,CAAC,CAACxB,UAAU,CAACgG,GAAG,CAACxE,CAAC,CAAC,CAAC;MAC/C;MAEA,IAAI0E,SAAS,GAAGD,UAAU,GAAGR,KAAK;;MAExC;MACM;MACN,IAAIU,qBAAqB,GAAG,CAAC;QAAEC,qBAAqB,GAAG,CAAC;MACxD,KAAK,IAAI5E,CAAC,GAAG,CAAC,EAAE4E,qBAAqB,GAAGF,SAAS,EAAE1E,CAAC,EAAE,EAAE;QACvD,IAAI6E,MAAM,GAAGL,GAAG,CAACxE,CAAC,CAAC;UAAE8E,MAAM,GAAGN,GAAG,CAACxE,CAAC,GAAC,CAAC,CAAC;QAEtC2E,qBAAqB,GAAGC,qBAAqB;QAC7CA,qBAAqB,IAAIC,MAAM,CAACrG,UAAU,CAACsG,MAAM,CAAC;MACnD;MAEA,IAAID,MAAM,IAAIvF,SAAS,IAAIwF,MAAM,IAAIxF,SAAS,EAAE;QAAE;QACjD,IAAIuF,MAAM,GAAGL,GAAG,CAAC,CAAC,CAAC;UAAEM,MAAM,GAAGN,GAAG,CAAC,CAAC,CAAC;UAAExE,CAAC,GAAG,CAAC;MAC5C;;MAEA;MACA,IAAI+E,YAAY,GAAKH,qBAAqB,GAAGD,qBAAqB,KAAM,CAAC,GAAK,CAACD,SAAS,GAAGC,qBAAqB,KAAKC,qBAAqB,GAAGD,qBAAqB,CAAC,GAAI,CAAC;MACxK,IAAIK,iBAAiB,GAAG7H,CAAC,CAACc,YAAY,CAAC6F,yBAAyB,CAACe,MAAM,EAAEC,MAAM,EAAEC,YAAY,CAAC;MAC9F,OAAO;QACNjE,MAAM,EAAE1C,GAAG,CAACuC,SAAS,CAACqE,iBAAiB,EAAE5E,OAAO,CAAC;QACjDmE,WAAW,EAAEvE,CAAC,GAAC;MAChB,CAAC;IACC,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIiF,YAAY,EAAE,SAAAA,CAAU7G,GAAG,EAAEmE,QAAQ,EAAE7D,MAAM,EAAE;MAC3C,IAAIZ,OAAO,GAAGyE,QAAQ,CAAC1C,UAAU,CAAC,CAAC;MACnC,IAAInB,MAAM,CAACwG,MAAM,CAACpH,OAAO,CAAC,CAAC,CAAC,CAAC,EACzB,OAAO,GAAG;MACd,IAAIY,MAAM,CAACwG,MAAM,CAACpH,OAAO,CAACA,OAAO,CAAC2B,MAAM,GAAC,CAAC,CAAC,CAAC,EACxC,OAAO,GAAG;MAEd,IAAIyE,KAAK,GAAG/G,CAAC,CAACc,YAAY,CAACwC,OAAO,CAACrC,GAAG,EAAEmE,QAAQ,EAAE7D,MAAM,EAAE,KAAK,CAAC;QAC5DqB,OAAO,GAAG5C,CAAC,CAACc,YAAY,CAAC2B,kBAAkB,CAAC9B,OAAO,CAAC;QACpDqH,YAAY,GAAGpF,OAAO,CAACA,OAAO,CAACN,MAAM,GAAC,CAAC,CAAC;QACxC2F,OAAO,GAAG,CAAC;QACXC,KAAK,GAAG,KAAK;MACjB,KAAK,IAAIrF,CAAC,GAAC,CAAC,EAAEC,CAAC,GAAGnC,OAAO,CAAC2B,MAAM,GAAC,CAAC,EAAEO,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC5C,IAAIsF,EAAE,GAAGxH,OAAO,CAACkC,CAAC,CAAC;UACfuF,EAAE,GAAGzH,OAAO,CAACkC,CAAC,GAAC,CAAC,CAAC;QACrBoF,OAAO,GAAGrF,OAAO,CAACC,CAAC,CAAC;QACpB,IAAI7C,CAAC,CAACc,YAAY,CAACmB,cAAc,CAAC8E,KAAK,EAAEoB,EAAE,EAAEC,EAAE,EAAE,KAAK,CAAC,EAAE;UACrDH,OAAO,IAAIE,EAAE,CAAC9G,UAAU,CAAC0F,KAAK,CAAC;UAC/BmB,KAAK,GAAG,IAAI;UACZ;QACJ;MACJ;MACA,IAAI,CAACA,KAAK,EAAE;QACR,MAAM,wBAAwB,GAAG3G,MAAM,CAAC8G,QAAQ,CAAC,CAAC,GAAG,UAAU,GAAGjD,QAAQ,CAACiD,QAAQ,CAAC,CAAC;MACzF;MACA,OAAOJ,OAAO,GAAGD,YAAY;IACjC,CAAC;IAED;AACJ;AACA;AACA;AACA;IACIM,OAAO,EAAE,SAAAA,CAAUlD,QAAQ,EAAE;MACzB,OAAOpF,CAAC,CAACoF,QAAQ,CAACA,QAAQ,CAAC1C,UAAU,CAAC,CAAC,CAAC8C,KAAK,CAAC,CAAC,CAAC,CAAC8C,OAAO,CAAC,CAAC,CAAC;IAC/D,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,OAAO,EAAE,SAAAA,CAAUtH,GAAG,EAAEmE,QAAQ,EAAEoD,KAAK,EAAEC,GAAG,EAAE;MAC1C,IAAID,KAAK,GAAGC,GAAG,EAAE;QACb,OAAOzI,CAAC,CAACc,YAAY,CAACyH,OAAO,CAACtH,GAAG,EAAEjB,CAAC,CAACc,YAAY,CAACwH,OAAO,CAAClD,QAAQ,CAAC,EAAE,GAAG,GAACoD,KAAK,EAAE,GAAG,GAACC,GAAG,CAAC;MAC5F;;MAEA;MACAD,KAAK,GAAG/D,IAAI,CAACyC,GAAG,CAACzC,IAAI,CAAC0C,GAAG,CAACqB,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MACvCC,GAAG,GAAGhE,IAAI,CAACyC,GAAG,CAACzC,IAAI,CAAC0C,GAAG,CAACsB,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAEnC,IAAI9H,OAAO,GAAGyE,QAAQ,CAAC1C,UAAU,CAAC,CAAC;QAC/BgG,UAAU,GAAG1I,CAAC,CAACc,YAAY,CAACkG,iBAAiB,CAAC/F,GAAG,EAAEmE,QAAQ,EAAEoD,KAAK,CAAC;QACnEG,QAAQ,GAAG3I,CAAC,CAACc,YAAY,CAACkG,iBAAiB,CAAC/F,GAAG,EAAEmE,QAAQ,EAAEqD,GAAG,CAAC;MACnE;MACA,IAAID,KAAK,IAAIC,GAAG,EAAE;QACd,IAAI1B,KAAK,GAAG/G,CAAC,CAACc,YAAY,CAACkG,iBAAiB,CAAC/F,GAAG,EAAEmE,QAAQ,EAAEqD,GAAG,CAAC;QAChE,OAAO,CAAC1B,KAAK,CAACpD,MAAM,CAAC;MACzB;MACA;MACA,IAAI+E,UAAU,CAACtB,WAAW,IAAI,CAAC,CAAC,EAC5BsB,UAAU,CAACtB,WAAW,GAAG,CAAC;MAC9B,IAAIuB,QAAQ,CAACvB,WAAW,IAAI,CAAC,CAAC,EAC1BuB,QAAQ,CAACvB,WAAW,GAAG,CAAC;MAC5B,IAAInC,MAAM,GAAGtE,OAAO,CAAC6E,KAAK,CAACkD,UAAU,CAACtB,WAAW,GAAC,CAAC,EAAEuB,QAAQ,CAACvB,WAAW,GAAC,CAAC,CAAC;MAC5EnC,MAAM,CAAC2D,OAAO,CAACF,UAAU,CAAC/E,MAAM,CAAC;MACjCsB,MAAM,CAAClC,IAAI,CAAC4F,QAAQ,CAAChF,MAAM,CAAC;MAC5B,OAAOsB,MAAM;IACjB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;IACI4D,QAAQ,EAAE,SAAAA,CAAUzD,QAAQ,EAAE0D,KAAK,EAAE;MACjC,IAAI,CAACA,KAAK,EAAE,OAAO,KAAK;MACxB,IAAIC,GAAG,GAAG3D,QAAQ,CAAC1C,UAAU,CAAC,CAAC;QAC3BsG,GAAG,GAAGF,KAAK,CAACpG,UAAU,CAAC,CAAC;MAC5B,OAAQqG,GAAG,CAACA,GAAG,CAACzG,MAAM,GAAC,CAAC,CAAC,CAAEyF,MAAM,CAACiB,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7C,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;IACIC,OAAO,EAAE,SAAAA,CAAU7D,QAAQ,EAAE0D,KAAK,EAAE;MAChC,IAAI,CAACA,KAAK,EAAE,OAAO,KAAK;MACxB,IAAIC,GAAG,GAAG3D,QAAQ,CAAC1C,UAAU,CAAC,CAAC;QAC3BsG,GAAG,GAAGF,KAAK,CAACpG,UAAU,CAAC,CAAC;MAC5B,OAAQqG,GAAG,CAAC,CAAC,CAAC,CAAEhB,MAAM,CAACiB,GAAG,CAACA,GAAG,CAAC1G,MAAM,GAAC,CAAC,CAAC,CAAC;IAC7C,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;IACI4G,iBAAiB,EAAE,SAAAA,CAAU9D,QAAQ,EAAE0D,KAAK,EAAE;MAC1C,IAAI,CAACA,KAAK,EAAE,OAAO,KAAK;MACxB,IAAIC,GAAG,GAAG3D,QAAQ,CAAC1C,UAAU,CAAC,CAAC;QAC3BsG,GAAG,GAAGF,KAAK,CAACpG,UAAU,CAAC,CAAC;QACxB8F,KAAK,GAAGO,GAAG,CAAC,CAAC,CAAC;MAClB,OAAOP,KAAK,CAACT,MAAM,CAACiB,GAAG,CAAC,CAAC,CAAC,CAAC,IAAIR,KAAK,CAACT,MAAM,CAACiB,GAAG,CAACA,GAAG,CAAC1G,MAAM,GAAC,CAAC,CAAC,CAAC;IAClE,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;IACI6G,YAAY,EAAE,SAAAA,CAAS9C,CAAC,EAAEC,CAAC,EAAE;MACzB,OAAQ7B,IAAI,CAAC2E,KAAK,CAAC9C,CAAC,CAACnC,CAAC,GAAGkC,CAAC,CAAClC,CAAC,EAAEmC,CAAC,CAACrC,CAAC,GAAGoC,CAAC,CAACpC,CAAC,CAAC,GAAG,GAAG,GAAGQ,IAAI,CAAC4E,EAAE;IAC5D,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;IACIC,YAAY,EAAE,SAAAA,CAASjD,CAAC,EAAEC,CAAC,EAAE;MACzB,IAAIiD,CAAC,GAAG,CAACjD,CAAC,CAACnC,CAAC,GAAGkC,CAAC,CAAClC,CAAC,KAAKmC,CAAC,CAACrC,CAAC,GAAGoC,CAAC,CAACpC,CAAC,CAAC;QAC7BuF,CAAC,GAAGnD,CAAC,CAAClC,CAAC,GAAIoF,CAAC,GAAGlD,CAAC,CAACpC,CAAE;MACvB,OAAO;QAAC,GAAG,EAAEsF,CAAC;QAAE,GAAG,EAAEC;MAAC,CAAC;IAC3B,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,WAAW,EAAE,SAAAA,CAASxI,GAAG,EAAEyI,WAAW,EAAEC,QAAQ,EAAEC,YAAY,EAAE;MAC5D,IAAI3G,OAAO,GAAGhC,GAAG,CAACiC,UAAU,CAAC,CAAC;MAC9B,IAAID,OAAO,KAAKE,QAAQ,EACpBF,OAAO,GAAGhC,GAAG,CAACmC,OAAO,CAAC,CAAC;MAC3B,IAAIyG,QAAQ,GAAGF,QAAQ,GAAClF,IAAI,CAAC4E,EAAE,GAAC,GAAG;QAC/BS,MAAM,GAAG7I,GAAG,CAACoC,OAAO,CAACqG,WAAW,EAAEzG,OAAO,CAAC;QAC1C8G,OAAO,GAAG9I,GAAG,CAACoC,OAAO,CAACuG,YAAY,EAAE3G,OAAO,CAAC;QAC5C+G,EAAE,GAAGvF,IAAI,CAACwF,GAAG,CAACJ,QAAQ,CAAC,IAAEC,MAAM,CAAC7F,CAAC,GAAC8F,OAAO,CAAC9F,CAAC,CAAC,GAAGQ,IAAI,CAACyF,GAAG,CAACL,QAAQ,CAAC,IAAEC,MAAM,CAAC3F,CAAC,GAAC4F,OAAO,CAAC5F,CAAC,CAAC,GAAG4F,OAAO,CAAC9F,CAAC;QAClGkG,EAAE,GAAG1F,IAAI,CAACyF,GAAG,CAACL,QAAQ,CAAC,IAAEC,MAAM,CAAC7F,CAAC,GAAC8F,OAAO,CAAC9F,CAAC,CAAC,GAAGQ,IAAI,CAACwF,GAAG,CAACJ,QAAQ,CAAC,IAAEC,MAAM,CAAC3F,CAAC,GAAC4F,OAAO,CAAC5F,CAAC,CAAC,GAAG4F,OAAO,CAAC5F,CAAC;MACtG,OAAOlD,GAAG,CAACuC,SAAS,CAAC,IAAIxD,CAAC,CAACoK,KAAK,CAACJ,EAAE,EAACG,EAAE,CAAC,EAAElH,OAAO,CAAC;IACrD,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;IACIoH,OAAO,EAAE,SAAAA,CAASC,OAAO,EAAEC,OAAO,EAAE;MAChC,IAAIC,GAAG,GAAG/F,IAAI,CAAC4E,EAAE,GAAG,GAAG;QACnBoB,IAAI,GAAGH,OAAO,CAAClG,GAAG,GAAGoG,GAAG;QACxBE,IAAI,GAAGH,OAAO,CAACnG,GAAG,GAAGoG,GAAG;QACxBG,IAAI,GAAGL,OAAO,CAACpG,GAAG,GAAGsG,GAAG;QACxBI,IAAI,GAAGL,OAAO,CAACrG,GAAG,GAAGsG,GAAG;QACxBrG,CAAC,GAAGM,IAAI,CAACyF,GAAG,CAACU,IAAI,GAAGD,IAAI,CAAC,GAAGlG,IAAI,CAACwF,GAAG,CAACS,IAAI,CAAC;QAC1CzG,CAAC,GAAGQ,IAAI,CAACwF,GAAG,CAACQ,IAAI,CAAC,GAAGhG,IAAI,CAACyF,GAAG,CAACQ,IAAI,CAAC,GAC/BjG,IAAI,CAACyF,GAAG,CAACO,IAAI,CAAC,GAAGhG,IAAI,CAACwF,GAAG,CAACS,IAAI,CAAC,GAAGjG,IAAI,CAACwF,GAAG,CAACW,IAAI,GAAGD,IAAI,CAAC;MAE/D,IAAIN,OAAO,GAAG,CAAE5F,IAAI,CAAC2E,KAAK,CAACjF,CAAC,EAAEF,CAAC,CAAC,GAAG,GAAG,GAAGQ,IAAI,CAAC4E,EAAE,GAAI,GAAG,IAAI,GAAG;MAC9D,OAAOgB,OAAO,IAAI,GAAG,GAAGA,OAAO,GAAC,GAAG,GAAGA,OAAO;IACjD,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIQ,WAAW,EAAE,SAAAA,CAAStJ,MAAM,EAAEuJ,OAAO,EAAE9J,QAAQ,EAAE;MAC7C8J,OAAO,GAAG,CAACA,OAAO,GAAG,GAAG,IAAI,GAAG;MAC/B,IAAIN,GAAG,GAAG/F,IAAI,CAAC4E,EAAE,GAAG,GAAG;QACnB0B,MAAM,GAAG,GAAG,GAAGtG,IAAI,CAAC4E,EAAE;QACtB2B,CAAC,GAAGhL,CAAC,CAACiL,GAAG,CAACC,KAAK,CAACF,CAAC;QAAE;QACnBL,IAAI,GAAGpJ,MAAM,CAAC2C,GAAG,GAAGsG,GAAG;QACvBC,IAAI,GAAGlJ,MAAM,CAAC6C,GAAG,GAAGoG,GAAG;QACvBW,QAAQ,GAAGL,OAAO,GAAGN,GAAG;QACxBY,OAAO,GAAG3G,IAAI,CAACyF,GAAG,CAACO,IAAI,CAAC;QACxBY,OAAO,GAAG5G,IAAI,CAACwF,GAAG,CAACQ,IAAI,CAAC;QACxBa,QAAQ,GAAG7G,IAAI,CAACwF,GAAG,CAACjJ,QAAQ,GAAGgK,CAAC,CAAC;QACjCO,QAAQ,GAAG9G,IAAI,CAACyF,GAAG,CAAClJ,QAAQ,GAAGgK,CAAC,CAAC;QACjCN,IAAI,GAAGjG,IAAI,CAAC+G,IAAI,CAACJ,OAAO,GAAGE,QAAQ,GAAGD,OAAO,GACzCE,QAAQ,GAAG9G,IAAI,CAACwF,GAAG,CAACkB,QAAQ,CAAC,CAAC;QAClCP,IAAI,GAAGD,IAAI,GAAGlG,IAAI,CAAC2E,KAAK,CAAC3E,IAAI,CAACyF,GAAG,CAACiB,QAAQ,CAAC,GAAGI,QAAQ,GAClDF,OAAO,EAAEC,QAAQ,GAAGF,OAAO,GAAG3G,IAAI,CAACyF,GAAG,CAACQ,IAAI,CAAC,CAAC;MACrDE,IAAI,GAAGA,IAAI,GAAGG,MAAM;MACpBH,IAAI,GAAGA,IAAI,GAAG,GAAG,GAAGA,IAAI,GAAG,GAAG,GAAGA,IAAI,GAAG,CAAC,GAAG,GAAGA,IAAI,GAAG,GAAG,GAAGA,IAAI;MAChE,OAAO5K,CAAC,CAAC2D,MAAM,CAAC,CAAC+G,IAAI,GAAGK,MAAM,EAAEH,IAAI,CAAC,CAAC;IAC1C,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIa,KAAK,EAAE,SAAAA,CAASxK,GAAG,EAAEC,OAAO,EAAEC,OAAO,EAAE;MACrC,IAAIuG,MAAM,GAAGzG,GAAG,CAACyK,sBAAsB,CAACxK,OAAO,CAAC;QAC5CyG,MAAM,GAAG1G,GAAG,CAACyK,sBAAsB,CAACvK,OAAO,CAAC;QAC5CwI,QAAQ,GAAGlF,IAAI,CAAC2E,KAAK,CAACzB,MAAM,CAACxD,CAAC,GAAGuD,MAAM,CAACvD,CAAC,EAAEwD,MAAM,CAAC1D,CAAC,GAAGyD,MAAM,CAACzD,CAAC,CAAC,GAAG,GAAG,GAAGQ,IAAI,CAAC4E,EAAE,GAAG,EAAE;MACxFM,QAAQ,IAAIA,QAAQ,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC;MAClC,OAAOA,QAAQ;IACjB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIgC,oBAAoB,EAAE,SAAAA,CAAS1K,GAAG,EAAEC,OAAO,EAAEC,OAAO,EAAEH,QAAQ,EAAE;MAC9D,IAAI2I,QAAQ,GAAG3J,CAAC,CAACc,YAAY,CAAC2K,KAAK,CAACxK,GAAG,EAAEC,OAAO,EAAEC,OAAO,CAAC;QACtDI,MAAM,GAAGvB,CAAC,CAACc,YAAY,CAAC+J,WAAW,CAAC3J,OAAO,EAAEyI,QAAQ,EAAE3I,QAAQ,CAAC;MACpE,OAAOhB,CAAC,CAACc,YAAY,CAACkC,gBAAgB,CAAC/B,GAAG,EAAEM,MAAM,EAAEL,OAAO,EAAEC,OAAO,CAAC;IACvE;EACJ,CAAC,CAAC;EAEF,OAAOnB,CAAC,CAACc,YAAY;AAErB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}